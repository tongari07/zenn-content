---
title: "UIコンポーネントライブラリでスタイルを提供する方法"
emoji: "🏖️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: 
  -  "css"
  -  "frontend"
published: false
publication_name: "moneyforward"
---

複数のプロダクトやモノレポで共通利用するパッケージとして UI コンポーネントライブラリを作る時、技術選定似てどの方法を用いて開発するかが議題に上がります。当然選択した方法によって開発体験の良さや RSC に対応しているかなど比較する点は多くあります。しかしそれらの議論に進む前にまずスタイルを提供する方法を考える必要があります。

私は現在 40 以上あるプロダクトで共通利用されるデザインシステムの UI コンポーネントライブラリの開発に携わっています。そこで実際に上記のような議論が行われ、CSS Modules や Tailwind CSS、Zero-runtime CSS in JS などのさまざまなスタイリングの方法を横に並べて星取表を作り、メンバーそれぞれの観点や好みでどれを選択するかを議論していました。しかし、そもそもどのようにスタイルを提供するかを最初に決めていなかったため、議論が収束しないことに気づきました。そこで改めてスタイルを提供する方法を調査しメンバーに共有し再度議論したところ、議論はスムーズに収束しました。

この記事で想定している UI コンポーネントライブラリは様々の環境で利用される物です。導入先となるプロダクトやパッケージは多くの技術スタックやアーキテクチャを利用しています。UI コンポーネントライブラリではそれらの環境に依らず利用できる設計になっていないと、利用されず廃れてしまいます。

スタイルの提供方法も UI コンポーネントの汎用性を決める 1 つの要因です。

この記事ではその際に調べた方法とそれらのメリット・デメリット、そして私のチームで出した結論を記載します。
少しでも皆様の技術選定の助けになれば幸いです。

## スタイルの提供方法を決める上で重要な観点

ここでは共通利用される UI コンポーネントライブラリの、スタイルの提供方法を決めるために重要な観点を提示します。どれも重要ではありますが中でもプロダクトの状況や特性、チームのモチベーションなどを加味して優先度を決めることが重要です。

### 導入のしやすさ

導入が簡単かどうかも非常に重要です。プロダクトはそれぞれに解決すべき課題を持ち、それに向けた改善を日々行っています。そんな中、UI を統一するために UI コンポーネントライブラリを作ったからそれに移行してくれと言われたらどうでしょう。それだけでも負担を強いてしまうことになります。その上導入の負担が大きいと、優先度が大きく下がり一向に置き換えられないという事態に発展してしまいます。

そうならないようにするため、導入先のプロダクトの負担をなるべく減らすことが重要です。どの方法も一長一短ありますので、プロダクトの状況やチームのモチベーションも加味して選ぶことが重要です。

### 新しい技術スタックを強いないこと

UI コンポーネントライブラリを導入するために新しいライブラリをインストールしないといけない、という状況は避ける必要があります。依存先が増えることになりますので、今後のメンテナンスの負担が増えてしまいます。

例として Tailwind CSS のプリセットを提供して、アプリケーション側で組み込んでビルドする場合、アプリケーション側が Tailwind CSS を使っていない場合、新しくインストールしてビルドのフローに組み込む必要があります。これは利用者に新しい技術スタックを強いると同時に導入もしづらく好まれる方法ではありません。

しかし多くのプロダクトで同じライブラリを利用しているケースや、新しいライブラリを推進して統一していきたいというケースでは有効です。UI コンポーネントライブラリを起点にライブラリの統一が行われるので、より推進がしやすいことが考えられます。

### モダンなフレームワークとのシナジー

UI コンポーネントライブラリの導入先となるプロダクトの多くが App Router を使うプロダクトである場合、Emotion や styled-components などのランタイムでスタイルが生成される方法を利用するライブラリでコンポーネントを作ることが選択肢から外れます。

たとえば Next.js の App Router ではコンポーネントはデフォルトで Server Component となり最適化が行われます。その際、ライブラリのコンポーネントで Emotion が利用されている場合、Client Component として提供する必要があります。するとプロダクト側では Server Component のメリットを享受できなくなってしまいます。UI コンポーネントライブラリが提供するコンポーネントは汎用的なものが主なので、プロダクトの至る所で利用されます。そのコンポーネントが原因でプロダクトのパフォーマンスを損ねてしまうのは避ける必要があります。

## スタイルの提供方法の選択肢

内部で利用するライブラリに関わらず、UI コンポーネントライブラリやパッケージとして提供する上で使う側がどのようにスタイルを利用するかを選択する必要があります。プロジェクトの状態にもよって取れる選択肢は変わってきます。考えられる選択肢としては下記があります。

1. 1 つの CSS ファイルを提供する
2. 各コンポーネントの CSS ファイルをそれぞれ提供する
3. スタイリングライブラリのプリセットとして提供する
4. CSS in JS として提供する

私のチームでは「1 つの CSS ファイルを提供する」を選択しました。

### 1. 1つのCSSファイルを提供する

ライブラリ側で 1 つの CSS ファイルをエクスポートして、アプリケーション側ではその CSS ファイルを自身のグローバルな CSS ファイルでインポートします。スタイリングライブラリを利用する場合、ビルド時に静的な CSS ファイルを生成します。

```css:アプリケーション側でグローバルなスタイルを定義する global.css 内でインポートしている例

@import url('@tongari/my-components/styles.css');
```

この方法はのメリットの 1 つとして、シンプルな方法であることが挙げられます。アプリケーション側では 1 つのファイルのみをインポートし、global.css 内に 1 行するだけで全てのコンポーネントは最初からスタイルが当たった状態になります。

また静的な CSS ファイルを提供するため、アプリケーション側のスタイリングの方法に関わらず利用できます。当然、React Server Component などのサーバーでレンダリングされるコンポーネントでも利用できます。

さらにライブラリ側で利用するスタイリングの方法に関しても制限はなく、 Pure な CSS を利用したり、CSS Modules やスタイリングライブラリを利用する方法まで幅広い選択肢があります。

一方で全てのスタイルを 1 つにまとめて提供するため、コンポーネントの数が増えてスタイルが多くなるにつれて CSS ファイルのサイズが大きくなってしまい、利用していないコンポーネントのスタイルも全て含んだファイルがインポートされてしまいます。使っているスタイリングライブラリによっては重複するスタイルをまとめてることができたり、何らかの手段で CSS ファイルを圧縮することで、ある程度はファイルサイズを減らすことができますが、それでも限界はあります。

しかし、CSS ファイルのサイズがパフォーマンスに与える影響はその他の要因と比べて比較的小さく、共通利用が目的の UI コンポーネントライブラリではプロダクトと比べてもスタイルが複雑になりにくいです。そのため下記の他の選択肢と比べるとデメリットは少ないと言えます。

### 2. 各コンポーネントの CSS ファイルをそれぞれ提供する

この方法では提供するコンポーネント毎に CSS ファイルを用意し、コンポーネントの js ファイルや型定義ファイルと一緒にエクスポートします。アプリケーション側ではコンポーネントをインポートする際に CSS ファイルも一緒にインポートします。

```tsx:アプリケーション側でコンポーネントをインポートしたファイル内でインポートしている例
import { Button as CommonButton } from '@tongari07/my-components/Button';
import '@tongari07/my-components/Button/styles.css';

export const Button = (props) => {
  return <CommonButton {...props}/>
}
```

この方法ではアプリケーション側はコンポーネント毎のスタイルのみが定義された CSS ファイルをインポートするので、バンドルサイズを小さくできます。

さらに Next.js などのビルド時にページ毎に CSS ファイルをまとめるなどの最適化を行うフレームワークを利用している場合、最適化の対象になります。パフォーマンスを重要視した時に最も有力な方法となるでしょう。

加えて、1 つの CSS ファイルを提供する方法と同様に、静的な CSS ファイルを提供するため、サーバーでレンダリングされるコンポーネントでも利用できます。

一方で、アプリケーション側では新しいコンポーネントをインポートするたびに CSS も同じようにインポートする必要があります。上記の例のようにラッパーとなるコンポーネントを用意するか、グローバルな CSS ファイルにそれぞれ 1 つずつインポートする必要があります。アプリケーション側にラッパーとなるコンポーネントを作ることを強要したくない場合は、別の手段を取ることを推奨します。

また、j 調査した限りそれぞれのコンポーネントの CSS ファイルを別々に生成できる CSS in JS ライブラリが見つからず、おそらくこの方法はピュアな CSS か CSS Modules を利用することが前提になります。そのため、これはスタイリングの方法のメリデメになりますが、型安全に開発できません。（CSS Modules には型安全にする方法がサードパーティライブラリとして存在しますが、CSS in JS と比べると型の推論は弱い印象です）。

### 3. スタイリングライブラリのプリセットとして提供する

Tailwind CSS や CSS in JS ライブラリのプリセットをエクスポートし、アプリケーション側はそれを自身の設定にてインポートして組み込みます。UI コンポーネントライブラリでは同じ設定ファイルを利用してコンポーネントを実装し、アプリケーション側で自身のプロジェクトのコードと一緒にビルドすることで、ライブラリ側はビルド無しでコンポーネントを提供できます。

この方法の最大のメリットは、アプリケーション側でビルドするためライブラリの最適化のメリットを最大限に享受できることでしょう。例えば Tailwind CSS や Panda CSS では、ビルド時に重複しているスタイルを排除して CSS ファイルを生成してくれますが、この最適化にライブラリのコンポーネントも含めることができます。

一方でこの方法で提供されたコンポーネントを利用する場合、上述の通りアプリケーション側でビルドする必要があります。すでに同じスタイリングライブラリを利用している場合は問題ありませんが、違うスタイリングライブラリを利用している場合、新たにインストールしてビルドプロセスに含める必要があります。また、同じライブラリを利用している場合も、ライブラリで提供している設定と既存の設定の間に競合が発生するリスクがあります。

アプリケーション側のスタイリングライブラリが統一されている場合や、ライブラリの導入と同時にスタイリングライブラリを移行できる場合は、パフォーマンスや利用のしやすさを考慮すると非常に良い選択肢と言えます。

こちらの記事を参考にさせていただきました。
https://inside.pixiv.blog/2022/03/31/120000

### 4. CSS in JS として提供する

この方法では CSS ではなく、CSS in JS ライブラリを利用してコンポーネント内部でスタイルを定義したものをそのまま JavaScript ファイルとして提供します。RSC などのサーバーでレンダリングされるコンポーネントが出る以前のメジャーな方法です。主に Emotion や styled-components などを利用するのが一般的です。

この方法のメリット・デメリットはすでに多くの記事が出ていますので、ここでは省略します。
UI コンポーネントライブラリで利用することを考えた場合、RSC で使えないことは利用できる環境を制限してしまうため、大きなデメリットとなります。正確には MUI や Chakra UI が行なっているように、全てのコンポーネントをクライアントコンポーネントとして提供することで RSC の環境下でも利用できますが、最適化が行えなくなるためアプリケーション側のメリットを無くしてしまいます。

これらの理由から今後も RSC などを利用しない事を前提とした場合や上記のデメリットを享受できる場合以外では、この方法を利用するメリットはないと言えるでしょう。

こちらの記事を参考にさせていただきました。
https://zenn.dev/poteboy/articles/e9f63b87b3cd69

## まとめ

UI コンポーネントライブラリの技術選定において、スタイリングの方法を選択することに目が行きがちですが、まずは UI コンポーネントライブラリのユーザーであるプロダクトの開発者にどのようにスタイルを提供するかを検討する事に目を向ける必要があります。プロダクトの特性や技術スタックなどによってスタイルを提供する方法を検討する必要がありますので、丁寧に議論を進めることが重要です。

## 参考文献

https://inside.pixiv.blog/2022/03/31/120000
https://zenn.dev/poteboy/articles/e9f63b87b3cd69
